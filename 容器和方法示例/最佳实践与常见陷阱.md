# LeetCode 容器与算法 - 最佳实践与常见陷阱

> 汇总 C++ 和 Java 刷题中最有用的技巧、陷阱和性能对比

## C++ STL 最佳实践

### 选择正确的容器

| 操作场景 | 首选 | 原因 |
|---------|------|------|
| 频繁随机访问 | vector | O(1) 访问 |
| 频繁中间插删 | - | 避免！两端用 deque |
| 有序且需范围查 | map/set | O(log n) + 遍历有序 |
| 频繁查询存在性 | unordered_set | 平均 O(1) |
| 需要去重计数 | unordered_map | 键值对存储 |
| 单调栈 | stack + vector | stack 用于括号/单调 |
| BFS 遍历 | queue | FIFO 语义清晰 |
| 优先级处理 | priority_queue | 自动排序，O(log n) |

### 常见陷阱与修复

**1. vector 迭代遍历时删除**
```cpp
// 错误
for (auto it = v.begin(); it != v.end(); ++it) {
    if (/*删除条件*/) v.erase(it);  // 迭代器失效！
}

// 正确
for (auto it = v.begin(); it != v.end(); ) {
    if (/*删除条件*/) {
        it = v.erase(it);  // erase返回下一个迭代器
    } else {
        ++it;
    }
}

// 或者用新容器
vector<int> res;
for (int x : v) {
    if (/*保留条件*/) res.push_back(x);
}
```

**2. map[key] 自动插入陷阱**
```cpp
// 危险：会改变map大小
unordered_map<int, int> mp;
if (mp[key] > 0) { }  // mp[key]不存在时创建，值为0

// 安全做法
if (mp.count(key) && mp[key] > 0) { }
// 或
auto it = mp.find(key);
if (it != mp.end() && it->second > 0) { }
```

**3. set/map 遍历时修改**
```cpp
// 错误：改变key会破坏有序性
for (auto &p : mp) {
    p.first = 100;  // 不能改key
}

// 可以改value
for (auto &p : mp) {
    p.second = 100;  // 可以
}
```

**4. priority_queue 无 erase()**
```cpp
// 删除特定元素需要懒删除
unordered_set<int> deleted;  // 标记删除的元素
priority_queue<int> pq;

// 入队时额外信息
pq.push(x);

// 出队时检查
while (!pq.empty()) {
    int top = pq.top();
    pq.pop();
    if (deleted.count(top)) continue;  // 跳过标记删除
    // 处理 top
}
```

**5. unique() 只移动不删除**
```cpp
// 错误理解
vector<int> v = {1, 1, 2, 2, 3};
unique(v.begin(), v.end());  // v仍然有5个元素！

// 正确
auto last = unique(v.begin(), v.end());
v.erase(last, v.end());  // 现在真的删除了
```

### 性能对比

| 操作 | vector | list | unordered_set | set | deque |
|------|--------|------|--------------|-----|-------|
| 随机访问 | O(1) | O(n) | O(1) avg | O(log n) | O(1) |
| 前插 | O(n) | O(1) | - | - | O(1) |
| 中间插 | O(n) | O(1) | - | - | O(n) |
| 后插 | O(1) | O(1) | - | - | O(1) |
| 删除 | O(n) | O(1) | O(1) avg | O(log n) | O(n) |
| 查询 | O(n) | O(n) | O(1) avg | O(log n) | O(n) |

---

## Java Collections 最佳实践

### 什么时候用什么

| 场景 | 选择 | 关键特性 |
|------|------|--------|
| 动态数组，频繁访问 | ArrayList | 随机访问 O(1) |
| 链表，两端操作 | ArrayDeque | 推荐，比 LinkedList 快 |
| 栈和队列 | ArrayDeque | 比 Stack/Queue 性能好 |
| 键值存储，快查询 | HashMap | 平均 O(1) |
| 有序键值对 | TreeMap | O(log n)，范围查询 |
| 去重集合 | HashSet | 平均 O(1) |
| 有序不重复 | TreeSet | O(log n) |
| 优先级队列 | PriorityQueue | 默认小根堆 |

### 常见陷阱

**1. String 不可变，频繁修改低效**
```java
// 低效
String s = "";
for (int i = 0; i < n; i++) {
    s += i;  // 每次创建新对象，O(n²)
}

// 高效
StringBuilder sb = new StringBuilder();
for (int i = 0; i < n; i++) {
    sb.append(i);  // O(n)
}
String s = sb.toString();
```

**2. HashMap.get() 返回 null**
```java
// 容易出错
int count = map.get(key);
if (count > 0) { }  // NullPointerException！

// 安全做法
int count = map.getOrDefault(key, 0);
if (count > 0) { }
```

**3. 遍历时修改集合**
```java
// 错误：ConcurrentModificationException
for (int x : list) {
    if (x > 10) list.remove(x);  // 异常！
}

// 正确：用迭代器
Iterator<Integer> iter = list.iterator();
while (iter.hasNext()) {
    int x = iter.next();
    if (x > 10) iter.remove();  // 安全
}
```

**4. ArrayList.remove()两种重载**
```java
list.remove(0);           // 删除索引0的元素
list.remove(Integer.valueOf(10));  // 删除第一个值为10的元素
```

**5. 比较 equals() vs ==**
```java
// 错误
if (s1 == s2) { }  // 比较引用，不比较内容

// 正确
if (s1.equals(s2)) { }  // 比较内容

// 安全写法（防止NullPointerException）
if ("target".equals(s)) { }  // 反过来写
```

**6. PriorityQueue 默认小根堆**
```java
// 小根堆（默认）
PriorityQueue<Integer> pq = new PriorityQueue<>();

// 大根堆（需要指定比较器）
PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

// 自定义对象
PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> {
    return Integer.compare(a.priority, b.priority);
});
```

---

## 算法复杂度速查

### 排序算法

| 算法 | 最坏 | 平均 | 最好 | 空间 | 稳定 | 备注 |
|------|------|------|------|------|------|------|
| 快排 | O(n²) | O(n log n) | O(n log n) | O(log n) | 否 | C++ sort 使用 |
| 归并 | O(n log n) | O(n log n) | O(n log n) | O(n) | 是 | Java sort 对对象用 |
| 堆排 | O(n log n) | O(n log n) | O(n log n) | O(1) | 否 | |
| 插入 | O(n²) | O(n²) | O(n) | O(1) | 是 | 小数据快 |
| 冒泡 | O(n²) | O(n²) | O(n) | O(1) | 是 | 避免 |

### 数据结构操作

| 结构 | 访问 | 搜索 | 插入 | 删除 | 空间 |
|------|------|------|------|------|------|
| 数组 | O(1) | O(n) | O(n) | O(n) | O(n) |
| 链表 | O(n) | O(n) | O(1)* | O(1)* | O(n) |
| 哈希表 | - | O(1) avg | O(1) avg | O(1) avg | O(n) |
| BST | O(log n) | O(log n) | O(log n) | O(log n) | O(n) |
| 堆 | O(1) | O(n) | O(log n) | O(log n) | O(n) |

*: 需要已知位置指针

---

## 常用编程模式

### 1. 两指针
```cpp
// 用 unordered_set 不如双指针快
//快速定位两个元素和
sort(arr.begin(), arr.end());
int l = 0, r = arr.size() - 1;
while (l < r) {
    int sum = arr[l] + arr[r];
    if (sum == target) return {arr[l], arr[r]};
    if (sum < target) l++;
    else r--;
}
```

### 2. 滑动窗口
```cpp
// 维护窗口内的频率
unordered_map<char, int> window;
int left = 0;
for (int right = 0; right < s.size(); right++) {
    window[s[right]]++;
    while (/*缩小窗口条件*/) {
        window[s[left]]--;
        if (window[s[left]] == 0) window.erase(s[left]);
        left++;
    }
    // right 位置更新答案
}
```

### 3. 单调栈
```cpp
// 求下一个更大元素
stack<int> st;  // 存储下标，保证递减
vector<int> res(n, -1);
for (int i = n-1; i >= 0; i--) {
    while (!st.empty() && arr[st.top()] <= arr[i]) {
        st.pop();
    }
    if (!st.empty()) res[i] = arr[st.top()];
    st.push(i);
}
```

### 4. 区间 DP
```cpp
// dp[i][j] 表示 [i,j] 范围的答案
for (int len = 1; len <= n; len++) {
    for (int i = 0; i + len - 1 < n; i++) {
        int j = i + len - 1;
        // 转移
        for (int k = i; k < j; k++) {
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + cost);
        }
    }
}
```

### 5. BFS（队列）
```cpp
queue<Pair> q;
set<Pair> visited;
q.push(start);
visited.insert(start);

while (!q.empty()) {
    auto [x, y] = q.front();
    q.pop();
    
    for (auto [dx, dy] : directions) {
        int nx = x + dx, ny = y + dy;
        if (valid(nx, ny) && !visited.count({nx, ny})) {
            visited.insert({nx, ny});
            q.push({nx, ny});
        }
    }
}
```

### 6. Dijkstra（优先级队列）
```cpp
priority_queue<pair<int,int>, vector<pair<int,int>>, 
               greater<pair<int,int>>> pq;  // 小根堆
pq.push({0, start});
vector<int> dist(n, INT_MAX);
dist[start] = 0;

while (!pq.empty()) {
    auto [d, u] = pq.top();
    pq.pop();
    if (d > dist[u]) continue;  // 已处理过
    
    for (auto [v, w] : graph[u]) {
        if (dist[u] + w < dist[v]) {
            dist[v] = dist[u] + w;
            pq.push({dist[v], v});
        }
    }
}
```

---

## 快速调试技巧

### C++ 常用输出
```cpp
// 输出容器内容
for (int x : v) cout << x << " "; cout << "\n";

// 打印 map
for (auto &p : mp) cout << p.first << ":" << p.second << "\n";

// 调试时添加断言
assert(left <= right);
```

### Java 常用输出
```java
// 输出数组
System.out.println(Arrays.toString(arr));

// 输出List
System.out.println(list);

// 输出Map
System.out.println(map);
```

---

## 提交前查清单

- [ ] 是否考虑空输入？（空数组、空字符串）
- [ ] 是否考虑边界情况？（n=1、全相同元素）
- [ ] 整数溢出？用 long 不够用 BigInteger？
- [ ] 是否修改了输入数组？(题目是否要求)
- [ ] 复杂度是否符合时间限制？
- [ ] 是否有 off-by-one 错误？
- [ ] 是否正确处理了集合中的 null？

