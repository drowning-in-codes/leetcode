# 题型目录与经典题目（含 C++ 题解）

> 说明：按常见题型整理经典题目，覆盖入门/中等/困难。题解为精简可运行的 C++ 核心解法（LeetCode 风格 `class Solution`）。

## 1. 数组与哈希
- 入门：两数之和（Two Sum）
- 中等：三数之和（3Sum）
- 中等：颜色分类（Sort Colors）
- 中等：最长连续序列（Longest Consecutive Sequence）

**两数之和**
```cpp
#include <vector>
#include <unordered_map>
using namespace std;
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> pos;
        for (int i = 0; i < (int)nums.size(); ++i) {
            int need = target - nums[i];
            if (pos.count(need)) return {pos[need], i};
            pos[nums[i]] = i;
        }
        return {};
    }
};
```

**三数之和**
```cpp
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (i && nums[i] == nums[i-1]) continue;
            int l = i + 1, r = n - 1;
            while (l < r) {
                long long s = (long long)nums[i] + nums[l] + nums[r];
                if (s == 0) {
                    res.push_back({nums[i], nums[l], nums[r]});
                    int a = nums[l], b = nums[r];
                    while (l < r && nums[l] == a) ++l;
                    while (l < r && nums[r] == b) --r;
                } else if (s < 0) ++l; else --r;
            }
        }
        return res;
    }
};
```

## 2. 双指针与滑动窗口
- 入门：移动零（Move Zeroes）
- 中等：无重复字符的最长子串（Longest Substring Without Repeating Characters）
- 中等：最小覆盖子串（Minimum Window Substring）

**无重复字符的最长子串**
```cpp
#include <string>
#include <vector>
using namespace std;
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> last(256, -1);
        int ans = 0, start = 0;
        for (int i = 0; i < (int)s.size(); ++i) {
            if (last[s[i]] >= start) start = last[s[i]] + 1;
            last[s[i]] = i;
            ans = max(ans, i - start + 1);
        }
        return ans;
    }
};
```

**最小覆盖子串**
```cpp
#include <string>
#include <vector>
using namespace std;
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(128, 0);
        for (char c : t) need[c]++;
        int missing = t.size();
        int l = 0, bestLen = 1e9, bestL = 0;
        for (int r = 0; r < (int)s.size(); ++r) {
            if (need[s[r]] > 0) missing--;
            need[s[r]]--;
            while (missing == 0) {
                if (r - l + 1 < bestLen) bestLen = r - l + 1, bestL = l;
                need[s[l]]++;
                if (need[s[l]] > 0) missing++;
                l++;
            }
        }
        return bestLen == (int)1e9 ? "" : s.substr(bestL, bestLen);
    }
};
```

## 3. 栈与队列
- 入门：有效的括号（Valid Parentheses）
- 中等：最小栈（Min Stack）
- 中等：每日温度（Daily Temperatures）

**每日温度**
```cpp
#include <vector>
#include <stack>
using namespace std;
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& t) {
        int n = t.size();
        vector<int> ans(n, 0);
        stack<int> st;
        for (int i = 0; i < n; ++i) {
            while (!st.empty() && t[i] > t[st.top()]) {
                int j = st.top(); st.pop();
                ans[j] = i - j;
            }
            st.push(i);
        }
        return ans;
    }
};
```

## 4. 二分查找
- 入门：二分查找（Binary Search）
- 中等：搜索旋转排序数组（Search in Rotated Sorted Array）
- 困难：寻找两个正序数组的中位数（Median of Two Sorted Arrays）

**搜索旋转排序数组**
```cpp
#include <vector>
using namespace std;
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (nums[m] == target) return m;
            if (nums[l] <= nums[m]) {
                if (nums[l] <= target && target < nums[m]) r = m - 1;
                else l = m + 1;
            } else {
                if (nums[m] < target && target <= nums[r]) l = m + 1;
                else r = m - 1;
            }
        }
        return -1;
    }
};
```

## 5. 链表
- 入门：反转链表（Reverse Linked List）
- 中等：两两交换链表节点（Swap Nodes in Pairs）
- 困难：合并 K 个升序链表（Merge k Sorted Lists）

**反转链表**
```cpp
struct ListNode { int val; ListNode* next; ListNode(int x):val(x),next(nullptr){} };
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        while (head) {
            ListNode* nxt = head->next;
            head->next = prev;
            prev = head;
            head = nxt;
        }
        return prev;
    }
};
```

## 6. 二叉树与二叉搜索树
- 入门：二叉树的前序遍历（Preorder Traversal）
- 中等：二叉树的层序遍历（Level Order）
- 中等：验证二叉搜索树（Validate BST）
- 困难：二叉树最大路径和（Binary Tree Maximum Path Sum）

**层序遍历**
```cpp
#include <vector>
#include <queue>
using namespace std;
struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x):val(x),left(nullptr),right(nullptr){} };
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        queue<TreeNode*> q; q.push(root);
        while (!q.empty()) {
            int sz = q.size();
            vector<int> level;
            for (int i = 0; i < sz; ++i) {
                auto* node = q.front(); q.pop();
                level.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            res.push_back(level);
        }
        return res;
    }
};
```

## 7. 动态规划（重点）
- 入门：爬楼梯（Climbing Stairs）
- 中等：打家劫舍（House Robber）
- 中等：不同路径（Unique Paths）
- 中等：零钱兑换（Coin Change）
- 中等：最长递增子序列（LIS）
- 困难：最长公共子序列（LCS）
- 困难：股票系列（含交易次数限制/冷冻期/手续费）

**爬楼梯**
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        int a = 1, b = 2;
        for (int i = 3; i <= n; ++i) {
            int c = a + b;
            a = b; b = c;
        }
        return b;
    }
};
```

**零钱兑换**
```cpp
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        const int INF = 1e9;
        vector<int> dp(amount + 1, INF);
        dp[0] = 0;
        for (int i = 1; i <= amount; ++i) {
            for (int c : coins) {
                if (i >= c) dp[i] = min(dp[i], dp[i - c] + 1);
            }
        }
        return dp[amount] == INF ? -1 : dp[amount];
    }
};
```

**股票：一次交易**
```cpp
#include <vector>
using namespace std;
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minp = 1e9, ans = 0;
        for (int p : prices) {
            minp = min(minp, p);
            ans = max(ans, p - minp);
        }
        return ans;
    }
};
```

## 8. 回溯与搜索
- 入门：全排列（Permutations）
- 中等：子集（Subsets）
- 中等：组合总和（Combination Sum）
- 困难：N 皇后（N-Queens）

**全排列**
```cpp
#include <vector>
using namespace std;
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> cur; vector<int> used(nums.size(), 0);
        dfs(nums, used, cur, res);
        return res;
    }
private:
    void dfs(vector<int>& nums, vector<int>& used, vector<int>& cur, vector<vector<int>>& res) {
        if (cur.size() == nums.size()) { res.push_back(cur); return; }
        for (int i = 0; i < (int)nums.size(); ++i) {
            if (used[i]) continue;
            used[i] = 1; cur.push_back(nums[i]);
            dfs(nums, used, cur, res);
            cur.pop_back(); used[i] = 0;
        }
    }
};
```

## 9. 贪心
- 入门：分发饼干（Assign Cookies）
- 中等：跳跃游戏（Jump Game）
- 困难：合并区间变体（如最少箭数）

**跳跃游戏**
```cpp
#include <vector>
using namespace std;
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int far = 0;
        for (int i = 0; i < (int)nums.size(); ++i) {
            if (i > far) return false;
            far = max(far, i + nums[i]);
        }
        return true;
    }
};
```

## 10. 图与并查集
- 中等：岛屿数量（Number of Islands）
- 中等：课程表（Course Schedule）
- 困难：最短路径/最小生成树

**岛屿数量**
```cpp
#include <vector>
using namespace std;
class Solution {
public:
    int numIslands(vector<vector<char>>& g) {
        int m = g.size(), n = g[0].size();
        int cnt = 0;
        for (int i = 0; i < m; ++i) for (int j = 0; j < n; ++j) {
            if (g[i][j] == '1') { dfs(g, i, j); cnt++; }
        }
        return cnt;
    }
private:
    void dfs(vector<vector<char>>& g, int i, int j) {
        int m = g.size(), n = g[0].size();
        if (i < 0 || j < 0 || i >= m || j >= n || g[i][j] != '1') return;
        g[i][j] = '0';
        dfs(g, i+1, j); dfs(g, i-1, j); dfs(g, i, j+1); dfs(g, i, j-1);
    }
};
```

## 11. 字符串
- 入门：反转字符串（Reverse String）
- 中等：字符串相乘（Multiply Strings）
- 中等：最小窗口子串（见滑动窗口）
- 困难：正则表达式匹配（Regex Matching）

**字符串相乘**
```cpp
#include <string>
#include <vector>
using namespace std;
class Solution {
public:
    string multiply(string a, string b) {
        if (a == "0" || b == "0") return "0";
        int n = a.size(), m = b.size();
        vector<int> prod(n + m, 0);
        for (int i = n - 1; i >= 0; --i) for (int j = m - 1; j >= 0; --j) {
            int mul = (a[i]-'0') * (b[j]-'0');
            int sum = mul + prod[i + j + 1];
            prod[i + j + 1] = sum % 10;
            prod[i + j] += sum / 10;
        }
        string res;
        int i = 0; while (i < n + m && prod[i] == 0) ++i;
        for (; i < n + m; ++i) res.push_back('0' + prod[i]);
        return res;
    }
};
```

## 12. 位运算与数学
- 入门：只出现一次的数字（Single Number）
- 中等：比特位计数（Counting Bits）
- 中等：Pow(x, n)

**只出现一次的数字**
```cpp
#include <vector>
using namespace std;
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int x = 0;
        for (int v : nums) x ^= v;
        return x;
    }
};
```

## 13. 常见排序算法与复杂度

| 算法 | 最好时间 | 平均时间 | 最坏时间 | 额外空间 | 稳定性 |
| --- | --- | --- | --- | --- | --- |
| 冒泡排序 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 |
| 插入排序 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定 |
| 选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 |
| 归并排序 | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | 稳定 |
| 快速排序 | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ | 不稳定 |
| 堆排序 | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | 不稳定 |
| 希尔排序 | $O(n \log n)$ | 约 $O(n^{1.3})$ | $O(n^2)$ | $O(1)$ | 不稳定 |
| 计数排序 | $O(n + k)$ | $O(n + k)$ | $O(n + k)$ | $O(k)$ | 稳定 |
| 桶排序 | $O(n + k)$ | $O(n + k)$ | $O(n^2)$ | $O(n + k)$ | 视实现而定 |

**算法简要介绍与稳定性**
- 冒泡排序：相邻交换把最大元素逐步“冒”到末尾，稳定。
- 插入排序：维护前缀有序并插入当前元素，稳定。
- 选择排序：每轮选择最小值交换到前缀，交换会破坏相对次序，不稳定。
- 归并排序：分治后合并，合并时保持相对次序，稳定。
- 快速排序：分区递归，元素跨分区交换导致相对次序改变，不稳定。
- 堆排序：基于堆的选择与交换，交换会破坏相对次序，不稳定。
- 希尔排序：分组插入排序，跨组移动会打乱相对次序，不稳定。
- 计数排序：按计数回填，若按计数稳定回填则稳定。
- 桶排序：桶内排序若稳定且合并时保序则稳定，否则不稳定。

**归并排序（对应 Sort an Array）**
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        vector<int> tmp(nums.size());
        mergeSort(nums, tmp, 0, (int)nums.size() - 1);
        return nums;
    }

private:
    void mergeSort(vector<int>& a, vector<int>& tmp, int l, int r) {
        if (l >= r) return;
        int m = l + (r - l) / 2;
        mergeSort(a, tmp, l, m);
        mergeSort(a, tmp, m + 1, r);
        int i = l, j = m + 1, k = l;
        while (i <= m && j <= r) tmp[k++] = (a[i] <= a[j]) ? a[i++] : a[j++];
        while (i <= m) tmp[k++] = a[i++];
        while (j <= r) tmp[k++] = a[j++];
        for (int x = l; x <= r; ++x) a[x] = tmp[x];
    }
};
```

**快速排序（对应 Sort an Array）**
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, (int)nums.size() - 1);
        return nums;
    }

private:
    void quickSort(vector<int>& a, int l, int r) {
        if (l >= r) return;
        int i = l, j = r, pivot = a[l + (r - l) / 2];
        while (i <= j) {
            while (a[i] < pivot) ++i;
            while (a[j] > pivot) --j;
            if (i <= j) {
                int t = a[i]; a[i] = a[j]; a[j] = t;
                ++i; --j;
            }
        }
        if (l < j) quickSort(a, l, j);
        if (i < r) quickSort(a, i, r);
    }
};
```

**希尔排序（缩小增量的插入排序，常用序列如 n/2, n/4, ...）**
特点：通过分组减少逆序对，平均性能优于 $O(n^2)$ 的简单排序，但复杂度依赖增量序列。

**计数排序（适合整数范围不大）**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if (nums.empty()) return nums;
        int minv = *min_element(nums.begin(), nums.end());
        int maxv = *max_element(nums.begin(), nums.end());
        int range = maxv - minv + 1;
        vector<int> cnt(range, 0);
        for (int v : nums) cnt[v - minv]++;
        int idx = 0;
        for (int i = 0; i < range; ++i) {
            while (cnt[i]-- > 0) nums[idx++] = i + minv;
        }
        return nums;
    }
};
```

**桶排序（离散均匀分布时效果好）**
```cpp
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) return nums;
        int minv = *min_element(nums.begin(), nums.end());
        int maxv = *max_element(nums.begin(), nums.end());
        int bucketCount = max(1, (int)sqrt(n));
        int bucketSize = max(1, (maxv - minv) / bucketCount + 1);
        vector<vector<int>> buckets(bucketCount);
        for (int v : nums) {
            int idx = (v - minv) / bucketSize;
            if (idx >= bucketCount) idx = bucketCount - 1;
            buckets[idx].push_back(v);
        }
        int k = 0;
        for (auto& b : buckets) {
            sort(b.begin(), b.end());
            for (int v : b) nums[k++] = v;
        }
        return nums;
    }
};
```

## 14. 线段树
- 中等：区域和检索（可修改）
- 困难：区间更新（懒标记）

## 15. 树状数组（Fenwick）
- 中等：区域和检索（可修改）
- 中等：逆序对数量

## 16. 区间 DP
- 困难：戳气球（Burst Balloons）
- 中等：最长回文子序列
- 困难：回文串分割 II

## 17. 线性 DP
- 入门：最大子数组和
- 中等：最长连续递增序列
- 中等：最长公共子数组

## 18. 图论经典
- 中等：课程表 II（拓扑排序）
- 困难：单词接龙（BFS）
- 中等：打开转盘锁（BFS）
- 中等：二进制矩阵最短路径（BFS）
- 中等：连接所有点的最小费用（最小生成树）
- 中等：连接所有点的最小费用（最小生成树/Prim）
- 中等：中转最便宜航班（最短路/Bellman-Ford）
- 中等：网络延迟时间（最短路/Dijkstra）
- 中等：判断二分图
- 中等：Floyd 全源最短路（模板/场景）

**Floyd 应用场景与解法要点**
- 适合点数较小（如 $n \le 200$）的全源最短路问题，能一次性得到任意两点最短路。
- 典型场景：任意两点最短路矩阵、频繁查询两点最短距离、存在负权边且无负环。
- 核心转移：$dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$，三重循环枚举中间点 $k$。

---

# 大厂面试/笔试高频题清单（建议优先掌握）

- 数组/哈希：两数之和、三数之和、最长连续序列
- 双指针/滑窗：无重复最长子串、最小覆盖子串
- 栈：有效括号、每日温度、最小栈
- 二分：搜索旋转数组、寻找第一个/最后一个位置
- 链表：反转链表、合并 K 个链表、环形链表
- 树：层序遍历、最大路径和、验证 BST
- 图：岛屿数量、课程表、最短路径
- DP：爬楼梯、打家劫舍、零钱兑换、LIS、股票问题
- 回溯：全排列、子集、组合总和、N 皇后
- 贪心：跳跃游戏、区间调度
- 位运算：Single Number、Counting Bits
- 排序：快速排序、归并排序、堆排序

> 如需扩充到完整题库或生成对应独立文件题解，可继续指定范围与数量。